



# 4.对多次元数组的操作



本节对于多次元数组进行说明，并且通过不同函数的操作和使用进行理解。

Numpy中对于矩阵的乘法运算，并不是通过*进行的，而是使用```dot()```函数。

```python
c = np.ones([4,4])
c*c
```
array([[1., 1., 1., 1.],  
                             [1., 1., 1., 1.],  
                             [1., 1., 1., 1.],  
                             [1., 1., 1., 1.]])  
                             
```python
c.dot(c)
```
array([[4., 4., 4., 4.],  
                                  [4., 4., 4., 4.],  
                                  [4., 4., 4., 4.],  
                                  [4., 4., 4., 4.]])  
                                  
对于多次元数组的操作而言，最重要的主题就是对数组进行合并(stack), 

**Numpy的合并分别由水平方向的```vstack```和竖直方向的```hstack```函数进行，**

**同样的行列分割也分别为```vsplit```和```hsplit```。**

```python
y = np.arange(15).reshape(3, 5)
x = np.arange(10).reshape(2, 5)
new_array = np.vstack((y, x))
new_array
```
array([[ 0,  1,  2,  3,  4],  
                                   [ 5,  6,  7,  8,  9],  
                                   [10, 11, 12, 13, 14],  
                                   [ 0,  1,  2,  3,  4],  
                                   [ 5,  6,  7,  8,  9]])  
                                   
```python
y = np.arange(15).reshape(5, 3)
x = np.arange(10).reshape(5, 2)
new_array = np.hstack((y, x))
new_array
```
array([[ 0,  1,  2,  0,  1],  
                                   [ 3,  4,  5,  2,  3],  
                                   [ 6,  7,  8,  4,  5],  
                                   [ 9, 10, 11,  6,  7],  
                                   [12, 13, 14,  8,  9]])  
                                   
以上的方法，同样适用于机械学习中，特别是对数据组合的创建来说非常的有帮助。

合并后的数组的记述统计量可以通过```scipy.stats```函数进行确认。

有100个元素，且每个元素有10个特征的情况下，可以将其用一个拥有100行10列的2次元数组进行考虑，

如同如下所示的例子一，各个特征的记述统计量可以很简单的得到并表示出来。

```python
from scipy import stats
x = np.random.rand(100, 10) #创建一个100行10列的随机数组
n, min_max, mean, var, skew, kurt = stats.describe(x)
new_array = np.vstack((mean, var, skew, kurt, min_max[0], min_max[1]))
new_array.T
```
array([[ 4.24272544e-01,  7.86839912e-02,  4.41279364e-01,  
                                      -8.54466487e-01,  2.78909344e-03,  9.73187307e-01],  
                                     [ 4.62157871e-01,  7.25348490e-02,  2.32234172e-01,  
                                      -9.79523438e-01,  9.97326112e-03,  9.98974097e-01],  
                                     [ 4.78314326e-01,  8.10265407e-02,  1.15473062e-01,  
                                      -1.23939955e+00,  4.10545010e-03,  9.87804340e-01],  
                                     [ 5.17797870e-01,  8.59961141e-02,  9.47312948e-02,  
                                      -1.19372895e+00,  1.63047913e-02,  9.98905862e-01],  
                                     [ 5.30620748e-01,  6.81484693e-02, -2.11021743e-01,  
                                      -9.34844329e-01,  1.67227684e-02,  9.98465924e-01],  
                                     [ 5.28025886e-01,  8.73891741e-02, -1.17314384e-01,  
                                      -1.17747497e+00,  4.67713464e-03,  9.96919518e-01],  
                                     [ 4.61746820e-01,  8.36921480e-02,  8.08104625e-02,  
                                      -1.17524353e+00,  3.52058884e-03,  9.96844465e-01],  
                                     [ 5.06421630e-01,  8.20699613e-02, -5.12022820e-02,  
                                      -1.13708513e+00,  8.23944893e-03,  9.84196691e-01],  
                                     [ 5.22004280e-01,  9.14098986e-02, -1.01376790e-01,  
                                      -1.21825969e+00,  1.17838602e-02,  9.99229127e-01],  
                                     [ 4.75516966e-01,  7.48729301e-02,  2.33668855e-01,  
                                      -9.95367782e-01,  2.60008511e-04,  9.86002077e-01]])  
    
Numpy中的```numpy.ma```函数是一个对于数组元素进行隐藏(mask）的性能十分优秀的模块。

在计算中，需要无视数组中的一部分元素时十分便利。

将元素隐藏后，该元素将无法被操作，计算时被排除在计算外。

```python
import numpy.ma as ma
x = np.arange(6)
print(x.mean())
```
2.5
```python
masked_array = ma.masked_array(x, mask=[1, 0, 0, 0, 0, 0]) #隐藏第一项
masked_array.mean()
```
3.0
         
**这个方法在对NaN值进行置换的时候尤为便利。**

```python
x = np.arange(25, dtype = float).reshape(5, 5)
x[x<5] = np.nan
x
```
array([[nan, nan, nan, nan, nan],  
                          [ 5.,  6.,  7.,  8.,  9.],  
                          [10., 11., 12., 13., 14.],  
                          [15., 16., 17., 18., 19.],  
                          [20., 21., 22., 23., 24.]])  
                          
```python
np.where(np.isnan(x), ma.array(x, mask=np.isnan(x)).mean(axis=0), x)
```
array([[12.5, 13.5, 14.5, 15.5, 16.5],  
                        [ 5. ,  6. ,  7. ,  8. ,  9. ],  
                        [10. , 11. , 12. , 13. , 14. ],  
                        [15. , 16. , 17. , 18. , 19. ],  
                        [20. , 21. , 22. , 23. , 24. ]])               
    
前面的代码，是将带有指数(index)的最初五个要素置换成nan值，

然后将各列的平均值(除了nan值)添加到上面，

这样可以使数组操作十分便利的函数还有很多，也使得代码看起来尤为整洁。

| ;--- | :--- |
| np.concatenate | 将数组与其他数组结合 |
| np.repeat | 将数组元素沿指定轴重复 |
| np.delete | 将数组中的部分删除后返回新的数组 |
| np.insert | 在指定轴的前面插入(元素) |
| np.unique | 在数组中查找指定值 |
| np.tele | 创建一个由指定数值重复循环得到的数组 |
    
    
    
    
    
    
    
    
    
    
