



    在机械学系的项目中，经常会有操作非常巨大的数组的情况。因此，频繁的使用带有指数(index)函数、切片(slice)、
  形状变换、大小(size)变换等操作及函数是十分必要的。
    带有指数的函数是python中很常用的一种情况。他的主要目的是可以指定操作对象，得到对你有用的数据。
      1) x = ["USA", "France", "Germany", "English"]
         x[2]  ------  'Germany'
         
         x = ('USA', 3, "France", 4)
         x[1]  ------  3
         
    python本身对于这类带有指数属性的操作有着非常细致的语言描写，因此在使用中十分的便利。
      2) x = np.arange(10)
         x  ------  array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
         x[5]  ------ 5
         x[-2]  ------ 8
         x[2:8]  -------  array([2, 3, 4, 5, 6, 7])
         x[:]  ------  array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
         x[2:8:2]  ------  array([2, 4, 6]) # 第三引数表示间隔
    
    index操作是从0开始的，所以最初要素位置为x[0]，负数代表从后向前指定，x[-2]表示右数第二个值。
    所以到现在为止，已经学习了一次元数组的指数和切片操作。对于多次元数组实质原理相同，唯一变化的点是轴数
  增加了，因此在指定时使用的引数会增加。
      3) x = np.reshape(np.arange(16), (4,4))
         x  ------  array([[ 0,  1,  2,  3],
                           [ 4,  5,  6,  7],
                           [ 8,  9, 10, 11],
                           [12, 13, 14, 15]])
         x[1:3]  ------  array([[ 4,  5,  6,  7],
                                [ 8,  9, 10, 11]])
         x[:, 1:3]  ------  array([[ 1,  2],
                                  [ 5,  6],
                                  [ 8,  9],
                                  [12, 14]])
         x[1:3, 1:3]  ------  array([[ 5,  6],
                                     [ 9, 10]])
                                     
    上例是对数组进行了几种不同的切片操作，但是不规则的切片是没有办法进行的。也就是说，切片操作一般情况下
  是以正方形或者长方形进行操作的。接下来我们考虑一个4 × 4的数组切片。
    对于想要抓取的数据进行切片操作。
      5) x = np.reshape(np.arange(16), (4,4))
         x  ------  array([[ 0,  1,  2,  3],
                           [ 4,  5,  6,  7],
                           [ 8,  9, 10, 11],
                           [12, 13, 14, 15]])
         x[[0, 1, 2], [0, 1, 3]]  ------  array([0, 5, 11]) # x的两个[]中定义了横、竖坐标。                  
    
    reshape和resize是两个看起来很类似的函数，但事实上他们的输出是不同的。reshape会一时改变数组的输出形状，
  但是数组自身是没有变化的。resize是输出一个改变后的新数组，因此与原数组相比较，自身的内容是发生了改变的。
  另外，resize在创建数组大于原数组时，会将原数组内容重复以填充新数组；而创建数组小于原数组时，会将数组内容
  削减，以原数组元素按顺序填充新数组。具体事例如下。
      6) x = np.arange(16).reshape(4, 4)
         x  ------  array([[ 0,  1,  2,  3],
                           [ 4,  5,  6,  7],
                           [ 8,  9, 10, 11],
                           [12, 13, 14, 15]])
         np.resize(x, (2,2))  ------  array([[0, 1],
                                             [2, 3]])
         np.resize(x, (6,6))  ------  array([[ 0,  1,  2,  3,  4,  5],
                                             [ 6,  7,  8,  9, 10, 11],
                                             [12, 13, 14, 15,  0,  1],
                                             [ 2,  3,  4,  5,  6,  7],
                                             [ 8,  9, 10, 11, 12, 13],
                                             [14, 15,  0,  1,  2,  3]])
    
    本节最后介绍的重要的用法是，广播(broadcasting)。首先广播的适用条件是，两个数组的次元相同(形状完全相同)，
  或其中一个数组的次元为1。如果没有满足条件，系统将会报错。
      7) x = np.arange(16).reshape(4,4)
         y = np.arange(6).reshpe(2,3)
         x+y
         ---------------------------------------------------------------------------
         ValueError                                Traceback (most recent call last)
         <ipython-input-13-5df45c6ad900> in <module>
              1 x = np.arange(16).reshape(4,4)
              2 y = np.arange(6).reshape(2,3)
         ----> 3 x+y

         ValueError: operands could not be broadcast together with shapes (4,4) (2,3) 
  
    广播进行的是对位运算，并不是传统的矩阵运算。
      8) x = np.ones(16).reshape(4,4)
         y = np.arange(4)
         x*y  ------  array([[0., 1., 2., 3.],
                             [0., 1., 2., 3.],
                             [0., 1., 2., 3.],
                             [0., 1., 2., 3.]])
         x = np.arange(4).reshape(2,2)
         x  ------  array([[0, 1],
                           [2, 3]])
         y = np.arange(2).reshape(1,2)
         y  ------  array([[0, 1]])
         x*y  ------array([[0, 1],
                           [0, 3]])
                           
    下面解释内容节取自菜鸟教程(runoob.com)。
    
    广播的规则:

        让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。
        输出数组的形状是输入数组形状的各个维度上的最大值。
        如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。
        当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。
    
    简单理解：对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：

        数组拥有相同形状。
        当前维度的值相等。
        当前维度的值有一个是 1。

    若条件不满足，抛出 "ValueError: frames are not aligned" 异常。
    
    
    
    
    
    
    
    
    
         
     
