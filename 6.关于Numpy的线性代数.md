



# 6.关于Numpy的线性代数

    
线性代数，是代数学中的一个分支，线性代数是以线性方程、线性空间以及向量空间为焦点，

主要目的在于解连立的线性方程，但事实上非线性系也同样可以使用。

因为对于复杂的模型和系的思考是一件十分抽象的事情，所以我们会通过线性代数将其简单化并且求解。

在计算机科学当中，线性代数被很广泛的使用在机械学习方面。

机械学习的用途是对于高次元的数组进行操作，再将其变换成简单的线性方程，从而进行分析。

所以说在学习Numpy的过程中，线性代数的理解是不可或缺的一部分。

虽然本章使用的是Numpy库，但是关于线性代数函数的部分基本上都需要对于`scipy`库进行import。

Scipy内的函数，实质上也包含了Numpy的函数，换句话说Scipy是在Numpy的基础上衍生出的新的库，

因此在有条件的情况下，可以自行对Scipy进行学习。

我们在之前的学习中，已经对矩阵运算的点乘有所了解，这里再次复习一下关于点乘的使用。

```python
import numpy as np
a = np.arange(6).reshape(3,2)
b = np.arange(10).reshape(2,5)
print(a)
```
>[[ 0 1]  
>[ 2 3]  
>[ 4 5]]
```python
print(b)
```
>[[ 0 1 2 3 4]  
>[ 5 6 7 8 9]]
        
```python
np.dot(a,b)
```
>array([[ 5,  6,  7,  8,  9],  
>[15, 20, 25, 30, 35],  
>[25, 34, 43, 52, 61]])
```python
np.matmul(a,b)
```
>array([[ 5,  6,  7,  8,  9],  
>[15, 20, 25, 30, 35],  
>[25, 34, 43, 52, 61]])  
```python
a@b
```
>array([[ 5,  6,  7,  8,  9],  
>[15, 20, 25, 30, 35],  
>[25, 34, 43, 52, 61]])  
                            
内积(点乘)是机械学习算法中非常重要的一个部分。

实质上，**点乘表达的是两个向量的相似度。**已知向量a为有肿瘤，b为没有肿瘤，

当计算机通过机械学习的方法认识两个向量后，再给计算机输入第三个向量c，

计算机会通过点乘比较c与a、b的相似度，从而甄别c是否有肿瘤。

在两个以上数组进行乘法操作时，`linalg.multi_dot()`函数十分便利。

```python
from numpy.linalg import multi_dot
a = np.arange(12).reshape(4,3)
b = np.arange(15).reshape(3,5)
c = np.arange(25).reshape(5,5)
multi_dot([a, b, c])
```
>array([[ 1700,  1855,  2010,  2165,  2320],  
>[ 5300,  5770,  6240,  6710,  7180],  
>[ 8900,  9685, 10470, 11255, 12040],  
>[12500, 13600, 14700, 15800, 16900]])  
```python
a.dot(b).dot(c)
```
>array([[ 1700,  1855,  2010,  2165,  2320],  
>[ 5300,  5770,  6240,  6710,  7180],  
>[ 8900,  9685, 10470, 11255, 12040],  
>[12500, 13600, 14700, 15800, 16900]])  
   
因为np.dot()函数的运算是逐次运算的，而`linalg.multi_dot()`函数会自动选用最适化逻辑进行计算。

事实上，使用`multi_dot()`函数方法的计算时间相比减少7%左右，这个时间差会随着矩阵的数量和大小而急剧增加。
```python
import time
a = np.arange(120000).reshape(400,300)
b = np.arange(150000).reshape(300,500)
c = np.arange(200000).reshape(500,400)
start = time.time()
multi_dot([a, b, c])
ft = time.time()-start
print('Multi_dot tooks', time.time()-start,'seconds.')
```
>Multi_dot tooks 0.11882996559143066 seconds.
```python
start_ft = time.time()
a.dot(b).dot(c)
print('Chain dot tooks', time.time()-start_ft,'seconds.')
```
>Chain dot tooks 0.1562058925628662 seconds.
   
Numpy的线性代数库中，还有两个十分重要的方法`outer()`和`inner()`。

```python
a = np.arange(9).reshape(3,3)
b = np.arange(3)
print(a)
```
>[[ 0 1]  
>[ 2 3]  
>[ 4 5]]  
```python
print(b)
```
>[0 1 2]
        
```python
np.inner(a,b)
```
>array([ 5, 14, 23])
```python
np.outer(a,b)
```
>array([[ 0,  0,  0],  
>[ 0,  1,  2],  
>[ 0,  2,  4],  
>[ 0,  3,  6],  
>[ 0,  4,  8],  
>[ 0,  5, 10],  
>[ 0,  6, 12],  
>[ 0,  7, 14],  
>[ 0,  8, 16]])  
        
由上例可知，`inner()`函数是将数组的第i行的向量和标量的乘积的和作为数组第i元素。

上例中，

[0*0 + 1*1 + 2*2, 0*3 + 1*4 + 2*5, 0*6 + 1*7 + 2*8] = [ 5, 14, 23]

`outer()`函数的具体算法，我们通过下例来进行理解。
```python
a = np.arange(9)
np.ndim(a)
```
>1 # ndim是用来确定数组的维数(次元数)。
```python
np.outer(a,b)
```
array([[ 0,  0,  0],  
>[ 0,  1,  2],  
>[ 0,  2,  4],  
>[ 0,  3,  6],  
>[ 0,  4,  8],  
>[ 0,  5, 10],  
>[ 0,  6, 12],  
>[ 0,  7, 14],  
>[ 0,  8, 16]])  
        
`outer()`函数是计算向量的直积，将二次元数组平坦化后进行计算。

上例是将数组a对应的每一个元素作为标量分别与b数列的向量进行直乘得到了由9个向量组成的数组。

最后介绍一个新的函数`tensordot()`函数。先看下例。

```python
a = np.arange(12).reshape(2,3,2)
b = np.arange(48).reshape(3,2,8)
c = np.tensordot(a,b, axes = ([1,0],[0,1]))
print(a)
```
>[[[ 0  1]  
>[ 2  3]  
>[ 4  5]]  
>  
>[[ 6  7]  
>[ 8  9]  
>[10 11]]]  
```python
print(b)
```
>[[[ 0  1  2  3  4  5  6  7]
>[ 8  9 10 11 12 13 14 15]]

>[[16 17 18 19 20 21 22 23]
>[24 25 26 27 28 29 30 31]]

>[[32 33 34 35 36 37 38 39]
>[40 41 42 43 44 45 46 47]]]
        
```python
c
```
>array([[ 800,  830,  860,  890,  920,  950,  980, 1010],  
>[ 920,  956,  992, 1028, 1064, 1100, 1136, 1172]])
   
这里着重讲解一下`tensordot()`函数的具体运算。

首先，**`tensordot`函数有三个引数，第一二引数指代运算对象，**即上例中的a、b数组。

**第三引数axes用于指定运算坐标。**axes有两种形态，整数或元组。

axes为整数时，假设`tensordot(a,b, axes = n)`，表示数组a的最后n轴与b的前n轴按顺序求和。

**对应轴的大小必须完全匹配。**

axes为元组时，假设`tensordot(a,b, axes = (n,m))`,元组中前一个引数n表示数组a的坐标，

后一个引数m表示b坐标，引数n、m可为列表。

```python
np.random.seed(10)
A = np.random.randint(0,9,(3,4,5))
B = np.random.randint(0,9,(4,5,2))
C = np.tensordot(A,B, [(1,2),(0,1)])
C
```
>array([[233,  89],  
>[250, 234],  
>[199, 244]])  
       
**解释：**
* (1,2) 是对A而言，不是取第1，2轴，而是除去1,2 轴，所以要取的是第0轴
* (0,1) 是对B而言，不是取第0，1轴，而是除去0,1 轴，所以要取的是第2轴

上例中，A的形状为(3,4,5)，B的形状为(4,5,2)，因此axes引数将A进行数组分块变为(3,(4,5))型数组，

将B变为((4,5),2)型数组。(4,5)形状完全相同，因此A、B可以相乘，乘后变为(3,2)型数组。

**函数的输出内容是将取出(余下)的子数组进行点乘操作。**

回顾第一个`tensordot`函数的例子，引数将数组a、b划块后得到一个形状为(2,8)的数组，

验证数组内运算内容，a函数取出的子数组为第2轴，取该轴第一元素和最后一个元素，即

               [[0, 2,  4],   和   [[1, 3,  5],
                [6, 8, 10]]         [7, 9, 11]]

b函数取出的子数组同样为第2轴，取该轴第一元素与最后一个元素，即

               [[ 0,  8],     和   [[ 7, 15],
                [16, 24],           [23, 31],
                [32, 40]]           [39, 47]]

分别将a、b的第一元素与最后一元素进行点乘，得到结果分别为800和1172，与结果一致，验证结束。
 
   
   
   
   
   
   
   
   
   
   
