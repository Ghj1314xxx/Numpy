


# 22.损失函数和误差函数

前面讲解了监督式学习和无监督学习。

但是不管哪种机械学习算法，最重要的可以就是最适化问题。

最适化函数中实际执行的是，使损失函数最小化。

让我们想象一下想要将每个月的储蓄额给最适化的情况。

在封闭状态下，实际上就是让每个月的消费，也就是损失函数最小化。

构筑损失函数，一般都是从预测值和实际值的差开始的。

一般情况下，先对已制成模型的参数进行推理，然后进行预测。

对预测进行评价所要求出的主要指标就是计算与实际值之间的差。

损失函数根据模型的不同是不同的。

比如说，平均二乘误差在回归模型中是适用的，但是在分类模型的损失函数中却并不适合。

下面简单的介绍一些损失函数及其特点。

损失函数 | 公式 | 特点
:--- | :--- | :---
0-1损失函数(zero-one loss) | ![](https://github.com/Ghj1314xxx/Numpy/blob/master/Images/lossz.svg) | (1)0-1损失函数直接对应分类判断错误的个数，但是它是一个非凸函数，不太适用.
(2)感知机就是用的这种损失函数。但是相等这个条件太过严格，因此可以放宽条件，即满足 [公式] 时认为相等，![](https://github.com/Ghj1314xxx/Numpy/blob/master/Images/lossz1.svg)
绝对值损失函数 | ![](https://github.com/Ghj1314xxx/Numpy/blob/master/Images/l1.svg) | 计算预测值与目标值的差的绝对值
log对数损失函数 | ![](https://github.com/Ghj1314xxx/Numpy/blob/master/Images/losslog.svg) | (1) log对数损失函数能非常好的表征概率分布，在很多场景尤其是多分类，如果需要知道结果属于每个类别的置信度，那它非常适合。
(2)健壮性不强，相比于hinge loss对噪声更敏感。
(3)逻辑回归的损失函数就是log对数损失函数。
平方损失函数 |　![](https://github.com/Ghj1314xxx/Numpy/blob/master/Images/l2.svg) | 经常应用与回归问题
指数损失函数（exponential loss）| ![](https://github.com/Ghj1314xxx/Numpy/blob/master/Images/lossexp.svg) | 对离群点、噪声非常敏感。经常用在AdaBoost算法中。
Hinge损失函数 | ![](https://github.com/Ghj1314xxx/Numpy/blob/master/Images/lossh.svg) | (1)hinge损失函数表示如果被分类正确，损失为0，否则损失就为 [公式] 。SVM就是使用这个损失函数。
(2)一般的 [公式] 是预测值，在-1到1之间， [公式] 是目标值(-1或1)。其含义是， [公式] 的值在-1和+1之间就可以了，并不鼓励 [公式] ，即并不鼓励分类器过度自信，让某个正确分类的样本距离分割线超过1并不会有任何奖励，从而使分类器可以更专注于整体的误差。
(3) 健壮性相对较高，对异常点、噪声不敏感，但它没太好的概率解释。
感知损失(perceptron loss)函数 | ![](https://github.com/Ghj1314xxx/Numpy/blob/master/Images/lossper.svg) | 是Hinge损失函数的一个变种，Hinge loss对判定边界附近的点(正确端)惩罚力度很高。而perceptron loss只要样本的判定类别正确的话，它就满意，不管其判定边界的距离。它比Hinge loss简单，因为不是max-margin boundary，所以模型的泛化能力没 hinge loss强。
交叉熵损失函数 (Cross-entropy loss function) | ![](https://github.com/Ghj1314xxx/Numpy/blob/master/Images/losscross.svg) | 本质上也是一种对数似然函数，可用于二分类和多分类任务中。
(2)当使用sigmoid作为激活函数的时候，常用交叉熵损失函数而不用均方误差损失函数，因为它可以完美解决平方损失函数权重更新过慢的问题，具有“误差大的时候，权重更新快；误差小的时候，权重更新慢”的良好性质。
